# -*- coding: utf-8 -*-
"""RV_23/09.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u7pNKRIftNr02srApe6bec0_YxfZmY7Y
"""

# Importing required libraries
import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow

# --- 1. Frequency Domain Processing (Image) ---
# Load an image
image_path = '/download.jpg'  # Change this to your image path
img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Perform 2D FFT on the image
f = np.fft.fft2(img)
fshift = np.fft.fftshift(f)  # Shift the zero-frequency component to the center

# Visualize the FFT magnitude spectrum
magnitude_spectrum = np.abs(fshift)
plt.figure(figsize=(12, 6))

# Plot the original image
plt.subplot(1, 2, 1)
plt.imshow(img, cmap='gray')
plt.title('Original Image')
plt.axis('off')

# Plot the FFT magnitude spectrum
plt.subplot(1, 2, 2)
plt.imshow(np.log(1 + magnitude_spectrum), cmap='gray')
plt.title('Magnitude Spectrum (Log Scale)')
plt.axis('off')

plt.show()

# Create a low-pass filter (Ideal Low-pass Filter)
rows, cols = img.shape
crow, ccol = rows // 2, cols // 2  # center of the image
radius = 30  # You can adjust the radius of the filter

low_pass_filter = np.zeros((rows, cols), np.uint8)
cv2.circle(low_pass_filter, (ccol, crow), radius, 1, thickness=-1)

# Apply the low-pass filter in the frequency domain
fshift_lp = fshift * low_pass_filter
img_lp = np.fft.ifft2(np.fft.ifftshift(fshift_lp)).real

# Create a high-pass filter (Ideal High-pass Filter)
high_pass_filter = np.ones((rows, cols), np.uint8)
cv2.circle(high_pass_filter, (ccol, crow), radius, 0, thickness=-1)

# Apply the high-pass filter in the frequency domain
fshift_hp = fshift * high_pass_filter
img_hp = np.fft.ifft2(np.fft.ifftshift(fshift_hp)).real

# Show the filtered images
plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1)
plt.imshow(img_lp, cmap='gray')
plt.title('Low-pass Filtered Image')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(img_hp, cmap='gray')
plt.title('High-pass Filtered Image')
plt.axis('off')

plt.show()

# --- 2. Motion Detection (Video) ---
# Import necessary libraries
import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Initialize video capture
video_path = '/video.mp4'  # Change this to your video path
cap = cv2.VideoCapture(video_path)

# Initialize background subtractor (Using MOG2 background subtraction)
fgbg = cv2.createBackgroundSubtractorMOG2()

while cap.isOpened():
    ret, frame = cap.read()

    if not ret:
        break

    # Convert to grayscale
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Apply background subtraction
    fgmask = fgbg.apply(gray)

    # Find contours of the moving objects
    contours, _ = cv2.findContours(fgmask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # You can add additional processing here (e.g., drawing contours)
    # If you want to visualize the contours without bounding boxes, you can simply not draw them.

    # Show the current frame with motion detection
    # Show the foreground mask directly (without bounding boxes)
    cv2_imshow(fgmask)  # Display the foreground mask

    # Press 'q' to exit the video window (note that 'q' won't work in Colab)
    # For Colab, you can stop the video manually or run the code for a fixed number of frames.

    # Optional: break after a fixed number of frames (e.g., 100 frames)
    # If you want to stop after a set number of frames for testing:
    #   if cap.get(cv2.CAP_PROP_POS_FRAMES) >= 100:
    #       break

# Release the video capture and close all OpenCV windows
cap.release()
cv2.destroyAllWindows()